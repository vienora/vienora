interface SupplierMetrics {
  supplierId: string;
  supplierName: string;
  totalOrders: number;
  successfulOrders: number;
  cancelledOrders: number;
  averageShippingTime: number; // in days
  qualityScore: number; // 0-100
  customerSatisfaction: number; // 0-5 stars
  lastUpdated: Date;
  responseTime: number; // hours to respond to issues
  returnRate: number; // percentage
  onTimeDelivery: number; // percentage
  priceCompetitiveness: number; // 0-100 compared to market average
  inventoryAccuracy: number; // percentage of in-stock claims that are accurate
}

interface SupplierIncident {
  id: string;
  supplierId: string;
  orderId: string;
  type: 'late_shipping' | 'quality_issue' | 'out_of_stock' | 'price_change' | 'communication_issue';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  reportedAt: Date;
  resolvedAt?: Date;
  impact: number; // 1-10 scale
}

interface BlacklistEntry {
  supplierId: string;
  supplierName: string;
  reason: string;
  blacklistedAt: Date;
  blacklistedBy: string;
  severity: 'warning' | 'suspended' | 'banned';
  expiresAt?: Date;
  autoGenerated: boolean;
}

interface PerformanceThresholds {
  minimumQualityScore: number;
  minimumSuccessRate: number;
  maximumReturnRate: number;
  minimumOnTimeDelivery: number;
  maximumResponseTime: number;
  minimumCustomerSatisfaction: number;
}

class SupplierPerformanceTracker {
  private metrics: Map<string, SupplierMetrics> = new Map();
  private incidents: SupplierIncident[] = [];
  private blacklist: Map<string, BlacklistEntry> = new Map();

  private thresholds: PerformanceThresholds = {
    minimumQualityScore: 70,
    minimumSuccessRate: 85,
    maximumReturnRate: 15,
    minimumOnTimeDelivery: 80,
    maximumResponseTime: 24,
    minimumCustomerSatisfaction: 3.5
  };

  constructor() {
    this.loadFromStorage();
  }

  // Track a new order
  async trackOrder(supplierId: string, orderId: string, success: boolean, shippingDays?: number): Promise<void> {
    let metrics = this.metrics.get(supplierId);

    if (!metrics) {
      metrics = this.createNewSupplierMetrics(supplierId);
    }

    metrics.totalOrders++;
    if (success) {
      metrics.successfulOrders++;
    } else {
      metrics.cancelledOrders++;
    }

    if (shippingDays !== undefined) {
      // Update average shipping time
      const totalShippingTime = metrics.averageShippingTime * (metrics.totalOrders - 1) + shippingDays;
      metrics.averageShippingTime = totalShippingTime / metrics.totalOrders;
    }

    metrics.lastUpdated = new Date();
    this.metrics.set(supplierId, metrics);

    // Check if supplier should be flagged
    await this.evaluateSupplierPerformance(supplierId);
    this.saveToStorage();
  }

  // Report an incident
  async reportIncident(incident: Omit<SupplierIncident, 'id' | 'reportedAt'>): Promise<string> {
    const incidentId = `incident_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    const newIncident: SupplierIncident = {
      ...incident,
      id: incidentId,
      reportedAt: new Date()
    };

    this.incidents.push(newIncident);

    // Update supplier metrics based on incident
    await this.processIncident(newIncident);

    // Check if this incident warrants blacklisting
    await this.evaluateSupplierPerformance(incident.supplierId);

    this.saveToStorage();
    return incidentId;
  }

  // Add supplier to blacklist
  async blacklistSupplier(
    supplierId: string,
    reason: string,
    severity: BlacklistEntry['severity'] = 'warning',
    expiresAt?: Date,
    blacklistedBy: string = 'system'
  ): Promise<void> {
    const supplier = this.metrics.get(supplierId);
    const supplierName = supplier?.supplierName || supplierId;

    const blacklistEntry: BlacklistEntry = {
      supplierId,
      supplierName,
      reason,
      blacklistedAt: new Date(),
      blacklistedBy,
      severity,
      expiresAt,
      autoGenerated: blacklistedBy === 'system'
    };

    this.blacklist.set(supplierId, blacklistEntry);
    this.saveToStorage();

    console.warn(`ðŸš« Supplier ${supplierName} has been ${severity}: ${reason}`);
  }

  // Remove supplier from blacklist
  async removeFromBlacklist(supplierId: string): Promise<boolean> {
    const removed = this.blacklist.delete(supplierId);
    if (removed) {
      this.saveToStorage();
      console.log(`âœ… Supplier ${supplierId} removed from blacklist`);
    }
    return removed;
  }

  // Check if supplier is blacklisted
  isBlacklisted(supplierId: string): BlacklistEntry | null {
    const entry = this.blacklist.get(supplierId);

    if (!entry) return null;

    // Check if blacklist has expired
    if (entry.expiresAt && entry.expiresAt < new Date()) {
      this.blacklist.delete(supplierId);
      this.saveToStorage();
      return null;
    }

    return entry;
  }

  // Get supplier performance report
  getSupplierReport(supplierId: string): SupplierMetrics | null {
    return this.metrics.get(supplierId) || null;
  }

  // Get all supplier rankings
  getSupplierRankings(): SupplierMetrics[] {
    return Array.from(this.metrics.values())
      .sort((a, b) => this.calculateOverallScore(b) - this.calculateOverallScore(a));
  }

  // Get filtered suppliers (exclude blacklisted)
  getActiveSuppliers(): SupplierMetrics[] {
    return Array.from(this.metrics.values())
      .filter(supplier => !this.isBlacklisted(supplier.supplierId))
      .sort((a, b) => this.calculateOverallScore(b) - this.calculateOverallScore(a));
  }

  // Get suppliers by quality tier
  getSuppliersByTier(): { elite: SupplierMetrics[]; good: SupplierMetrics[]; poor: SupplierMetrics[] } {
    const activeSuppliers = this.getActiveSuppliers();

    return {
      elite: activeSuppliers.filter(s => this.calculateOverallScore(s) >= 85),
      good: activeSuppliers.filter(s => {
        const score = this.calculateOverallScore(s);
        return score >= 70 && score < 85;
      }),
      poor: activeSuppliers.filter(s => this.calculateOverallScore(s) < 70)
    };
  }

  // Get recent incidents
  getRecentIncidents(supplierId?: string, days: number = 30): SupplierIncident[] {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - days);

    return this.incidents
      .filter(incident =>
        incident.reportedAt >= cutoffDate &&
        (!supplierId || incident.supplierId === supplierId)
      )
      .sort((a, b) => b.reportedAt.getTime() - a.reportedAt.getTime());
  }

  // Private methods

  private createNewSupplierMetrics(supplierId: string): SupplierMetrics {
    return {
      supplierId,
      supplierName: this.getSupplierName(supplierId),
      totalOrders: 0,
      successfulOrders: 0,
      cancelledOrders: 0,
      averageShippingTime: 0,
      qualityScore: 80, // Default starting score
      customerSatisfaction: 4.0,
      lastUpdated: new Date(),
      responseTime: 12,
      returnRate: 5,
      onTimeDelivery: 90,
      priceCompetitiveness: 75,
      inventoryAccuracy: 95
    };
  }

  private getSupplierName(supplierId: string): string {
    const supplierNames: { [key: string]: string } = {
      'spocket': 'Spocket',
      'printful': 'Printful',
      'modalyst': 'Modalyst',
      'cj_dropshipping': 'CJ Dropshipping',
      'aliexpress': 'AliExpress'
    };

    return supplierNames[supplierId] || supplierId;
  }

  private async processIncident(incident: SupplierIncident): Promise<void> {
    const metrics = this.metrics.get(incident.supplierId);
    if (!metrics) return;

    // Adjust metrics based on incident type and severity
    const impactMultiplier = {
      low: 1,
      medium: 2,
      high: 3,
      critical: 5
    };

    const impact = incident.impact * impactMultiplier[incident.severity];

    switch (incident.type) {
      case 'quality_issue':
        metrics.qualityScore = Math.max(0, metrics.qualityScore - impact);
        metrics.returnRate = Math.min(100, metrics.returnRate + impact / 2);
        break;

      case 'late_shipping':
        metrics.onTimeDelivery = Math.max(0, metrics.onTimeDelivery - impact);
        metrics.averageShippingTime += impact / 2;
        break;

      case 'out_of_stock':
        metrics.inventoryAccuracy = Math.max(0, metrics.inventoryAccuracy - impact);
        break;

      case 'communication_issue':
        metrics.responseTime += impact;
        metrics.customerSatisfaction = Math.max(0, metrics.customerSatisfaction - impact / 10);
        break;

      case 'price_change':
        metrics.priceCompetitiveness = Math.max(0, metrics.priceCompetitiveness - impact);
        break;
    }

    metrics.lastUpdated = new Date();
    this.metrics.set(incident.supplierId, metrics);
  }

  private async evaluateSupplierPerformance(supplierId: string): Promise<void> {
    const metrics = this.metrics.get(supplierId);
    if (!metrics || metrics.totalOrders < 10) return; // Need minimum orders for evaluation

    const violations: string[] = [];

    // Check against thresholds
    if (metrics.qualityScore < this.thresholds.minimumQualityScore) {
      violations.push(`Quality score too low: ${metrics.qualityScore.toFixed(1)}`);
    }

    const successRate = (metrics.successfulOrders / metrics.totalOrders) * 100;
    if (successRate < this.thresholds.minimumSuccessRate) {
      violations.push(`Success rate too low: ${successRate.toFixed(1)}%`);
    }

    if (metrics.returnRate > this.thresholds.maximumReturnRate) {
      violations.push(`Return rate too high: ${metrics.returnRate.toFixed(1)}%`);
    }

    if (metrics.onTimeDelivery < this.thresholds.minimumOnTimeDelivery) {
      violations.push(`On-time delivery too low: ${metrics.onTimeDelivery.toFixed(1)}%`);
    }

    if (metrics.responseTime > this.thresholds.maximumResponseTime) {
      violations.push(`Response time too slow: ${metrics.responseTime.toFixed(1)} hours`);
    }

    if (metrics.customerSatisfaction < this.thresholds.minimumCustomerSatisfaction) {
      violations.push(`Customer satisfaction too low: ${metrics.customerSatisfaction.toFixed(1)}/5`);
    }

    // Auto-blacklist if multiple severe violations
    if (violations.length >= 3) {
      await this.blacklistSupplier(
        supplierId,
        `Multiple performance violations: ${violations.join(', ')}`,
        'suspended',
        new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 days
      );
    } else if (violations.length >= 2) {
      await this.blacklistSupplier(
        supplierId,
        `Performance issues: ${violations.join(', ')}`,
        'warning',
        new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
      );
    }
  }

  private calculateOverallScore(metrics: SupplierMetrics): number {
    const successRate = metrics.totalOrders > 0 ? (metrics.successfulOrders / metrics.totalOrders) * 100 : 0;

    // Weighted scoring system
    const weights = {
      qualityScore: 0.25,
      successRate: 0.20,
      onTimeDelivery: 0.20,
      customerSatisfaction: 0.15,
      inventoryAccuracy: 0.10,
      priceCompetitiveness: 0.10
    };

    const normalizedSatisfaction = (metrics.customerSatisfaction / 5) * 100;

    return (
      metrics.qualityScore * weights.qualityScore +
      successRate * weights.successRate +
      metrics.onTimeDelivery * weights.onTimeDelivery +
      normalizedSatisfaction * weights.customerSatisfaction +
      metrics.inventoryAccuracy * weights.inventoryAccuracy +
      metrics.priceCompetitiveness * weights.priceCompetitiveness
    );
  }

  private loadFromStorage(): void {
    // In a real app, this would load from a database
    // For now, we'll use localStorage simulation
    try {
      const stored = typeof window !== 'undefined' ? localStorage.getItem('supplierMetrics') : null;
      if (stored) {
        const data = JSON.parse(stored);
        this.metrics = new Map(data.metrics || []);
        this.incidents = data.incidents || [];
        this.blacklist = new Map(data.blacklist || []);
      }
    } catch (error) {
      console.warn('Failed to load supplier metrics from storage:', error);
    }
  }

  private saveToStorage(): void {
    // In a real app, this would save to a database
    try {
      const data = {
        metrics: Array.from(this.metrics.entries()),
        incidents: this.incidents,
        blacklist: Array.from(this.blacklist.entries())
      };

      if (typeof window !== 'undefined') {
        localStorage.setItem('supplierMetrics', JSON.stringify(data));
      }
    } catch (error) {
      console.warn('Failed to save supplier metrics to storage:', error);
    }
  }
}

export const supplierTracker = new SupplierPerformanceTracker();
export type { SupplierMetrics, SupplierIncident, BlacklistEntry, PerformanceThresholds };
